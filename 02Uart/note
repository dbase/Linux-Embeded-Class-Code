arm是小端的
arm里面区分char和unsinged char 
arm里面一般采用4字节对齐

8O1(8位有效位偶校验O，一个校验位，一个停止位，停止位默认不写)
7E2(7位有效位奇校验Even,2个校验位，一个停止位)
8N1(8位有效位无校验，后跟一个停止位)

串口：提高传输电压，提高传输频率来解决传输过程中的衰减问题

串口编程中不再需要GPADAT寄存器(因为我们发送/接收的数据在串口的UTXH0/URXH0)，
只需要配置GPACON(指明我们使用UART RXD[0]和UART TXD[0]来接收/发送数据) 和
GPAPUD寄存器(用来指定我们是否使用pull-up register，也就是上拉电阻，来保证特定的数据状态1/0)。

 (在手册中31章专门讲解串口通讯)
 

1.串口通讯中，正电平代表低电平，负电平代表高电平，0表未发送任何数据，叫做停止位
   (注意：低电平不一定是负电平；高电平也不一定正电平，有一个相对的概念)

   在ARM串口中， (+1~+11V)表示接收到 0；
	       (-1~-11V)表示接受到 1；
               (-1~+1V) 表示没有输入，也就是停止位。

2.通讯双方需要指定数据传输的规则：
	8O1(8位有效位偶校验O，一个停止位/校验位)
	7E2(7位有效位奇校验Even,2个停止位)
	8N1(8位有效位无校验，1个停止位)

	1.奇校验：0的个数是奇数。ODD
	  偶校验：0的个数是偶数。EVEN
	  8O1：8位代表一个数据，1位奇校验
	  7E2：7位代表一个数据，2位偶校验
          8N1：8位代表一个数据，不校验
          如：8N1,115200

        通信双方的时间（波特率）需要同步

串口的FIFO：发送或接收数据时，先用一个简单的存储结构存储数据，达到一定量时一起发送或接收，发送或接收顺序和数据处理顺序相同，相当于FIFO。

波特率：
1.DIV_VAL = (PCLK / (bps x 16 ) ) −1 
DIV_VAL = (EXT_UCLK0 / (bps x 16 ) ) −1 
 	or 
DIV_VAL = (EXT_UCLK1 / (bps x 16 ) ) −1
将DIV_VAL写入UBRDIV n寄存器，bps就是所需要的波特率。
2.波特率微调：
(num of 1’s in UDIVSLOTn)/16 = 0.7 
 num of 1’s in UDIVSLOTn≈11
 then, (num of 1’s in UDIVSLOTn) = 11
从表中查出对应的值放入UDIVSLOT n寄存器中。

================================================================================
硬件的编程方法：
	1。GPIO  ：直接操作CPU的GPIO端口
	2。控制器 ：通过控制器来操作IO端口，这些控制器在CPU内部，比如串口控制器
	3。独立控制器：要先通过GPIO来和独立芯片控制器进行通讯，然后再由其进行数据处理，比如网卡


	DM9000网卡注记：
		CS＃ ：片选信号，低电平有效
		IOR＃：读使能端，低电平有效，默认为高电平
		IOW＃：写使能端，低电平有效，默认为高电平
		CMD  ：确定数据为存入的 值 还是 内部寄存器的索引(index)

		片选－－写/读使能－－获得地址－－数据处理
		访问地址就会激活/片选指定的设备

	 对于DM9000的控制，实际上是通过对网卡中的内存nor flash进行读写数据来控制的。而之前的LED是
	 通过设置设备的寄存器来进行的。
	 
	 由于DM9000通过16／8 bits和CPU连接，所以需要区分传入的数据是 “数据”还是“内部寄存器的INDEX” ，这是
	 通过CMD引脚来实现的。CMD为1表示为数据；CMD为0表示为INDEX。

	 高速设备一般都是把设备内部的寄存器直接编址到CPU的内存空间，提高数据传输的速度。

         关于DM9000的地址范围在6410手册的116页,DM9000的10页。

	 网卡发送一个数据包的步骤：
	 对于寄存器，要先索引，再写入数据;多字节时，只需要一次索引，多次写入即可	 
	  1。检查0xFEH寄存器确定传输mode：16bits/8bits  (P24)
	  2。将要发送的数据发送到特定寄存器0xF8H(会自增加TX的写指针)／0xF6H(没有TX写指针自增加)中，
                然后会自动装入TX SRAM寄存器。 (P23)
	  3。指定发送数据包的长度／字节数,放到0xFC~0xFDH寄存器中 。最小64B，最大1.5KB  (P23)		
	  4。设定发送指令 0x02H寄存器  (P15)
	  5。检测是否已经发送完毕。可以通过0xFEH第1位来检测 或者 通过0x1H 寄存器,若完毕则将其置0，写入1即可
	  	该寄存器写入1会将其置反，写入0不变。所以，寄存器和存储器是不同的

	  接收一个数据包的步骤：
	  RX SRAM里面存放的是完整的数据包，不仅仅是纯数据。
	  1。检测是否有数据可读
	     我们可以使用中断的方式来告诉CPU有数据 或 通过检测0xFEH的第0位来检测是否有数据来临。
	  2。从F0H中读取数据，看第1B是否为“01”，为01表示有数据，则进行第4步，不带自偏移
	     0xF0H寄存器会从RX SRAM里面自动读取特定部分的数据，注意，RX SRAM中的读指针是否自偏移
	     (注意：选择F0/F2)
	  3。若F0H中的不是00，则意味着数据包错误，需要禁止再向RX ROM中写入数据，重新启动网卡。
	  4。读取0xFEH确定传输mode：16bits/8bits,
	     然后，从0xf2中读取数据包，带自偏移
	  5。退出

================================================================================
	网络协议的创建：
	定义协议包的话，我们可以采用定义一个结构体，但是使用结构体在网络上传输，会出现两个问题：
		1。int/short字节序问题   htons()
		2。内存对齐问题          __attribute__((packed))
