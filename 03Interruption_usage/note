对硬件编程的方法总结：
	1。使用IO进行编程
	通用的编程方法：首先查看硬件连接图，找到与之相连的IO端口线，再看CORE原理图，找到与之对应的
	寄存器，最后是编程手册，通过对这些寄存器的控制就可以控制硬件。比如LED灯，按键等。
	2。使用CPU内部控制器编程
	该类设备的编程，我们往往需要了解相应的协议，然后通过CPU直接与控制器进行通讯来进行。
	比如，串口控制器等。
	3。使用CPU外部控制器编程
	要求我们同时了解该硬件的控制器和ARM CPU，注意其特殊的连接方式。
	比如网卡，声卡，USB控制器等。

================================================================================
ARM 的启动：
    1。启动代码存储设备的选择
	SDRAM：1.不加电的情况下无法保存数据 2.类似于内存，使用的时需要先进性刷新频率设置等
		SDRAM：synchron dynamic RAM 同步动态RAM
	E ROM ：  1.nand flash,容易产生坏块.不可以，因为它的读写都是以页为单位的，但CPU开始时需要安4字节来取指
	          2.nor flash ,可以，不容易产坏快，由于价格昂贵，只用于存储关键的数据和引导程序。
        SRAM：不可以，不加电就会丢失数据，static RAM 静态ARM
	SROM : 可以使用，又可以分成：
	    内部ROM：有时内部ROM不允许修改，所以它内部往往存储的是从SD卡/Nand flash等里面读取
	             引导程序进行加载，我们就可以通过修改SD卡/nand flash中的内容来修改启动程序。
	    外部ROM：可以直接修改ROM内部的数据
	
    我们常用的是采用SROM的两种方式。
    还有第三中启动方式：在ARM CPU中存在一个硬件逻辑芯片，首先把Steping Stone映射到0x0地址，然后
    把nand flash前8KB(6410中)复制到Stepping Stone的位置来启动。

    (P123  查看XSELNAN：Device operating mode selection at boot-up)
    
    可以参看手册 P116页。
    0x00000000-0x07ffffff   实际内存
    0x08000000-0x0bffffff   internal ROM 
    0x0C000000-0x0FFFFFFF   Stepping Stone (Boot Loader) 外部ROM
    0x1000_0000 0x17FF_FFFF 128MB SROMC Bank0－Bank5   外部SROM
>>>>>>>>>>>>>>>>>>>
  1.从IROM启动步骤
    从内部ROM中启动，IROM是由厂家固化的。首先，调整拨码开关选择从IROM启动，也就是把IROM的地址映射到0x0地址，
    然后，IROM从oneNand或SD卡中读取前8KB的内容放到Stepping Stone中，再把Stepping Stone映射到0x0地址进行启动。
    之所以还要把SteppingStone映射到0x0地址，是因为我们要自定义中断处理，而IROM是不允许修改的，所以要把SteppinStone
    映射到0x0地址。
  
  2.启动程序的编写
	1.各种模式的堆栈指针初始化
	sq_irq,sp_svc,....
	2.清零bss段
	3.初始化时钟
	5。硬件地址初始化  (arm11以上系列,地址映射)
	可选：
	4。内存初始化
	5。输入输出设备初始化

在清空bss段以后，我们要进行地址映射，因为CPU规定必须分别通知它设备使用的内存空间，
因为 ARM11 会对设备地址采用不同的处理方式。


Watchdog:主要是用来检测程序是正常状态，还是异常状态，若是异常状态就重新启动系统。
具体实现就是：我们的程序每隔特定的时间，向写WTCON寄存写入数据，如果超过时间还没有写入，则认定是出现异常。
Watchdog在 ARM11 中默认是启动的，所以，我们在写引导程序的时候，需要自己禁止它，以免我们的程序重启。

================================================================================
    时钟频率
    时钟的产生有很多中方式，但是最基本的原理是：利用一个非门，然后把非门的输出导入到其输入，利用电路传递的
    延迟来获得高低电平，但是时间间隔不可控。
    一般有两种方式;
	1.RC震荡电路
	  高频电路中，电阻也会具有电容和电感的效果。所以RC震荡电路具有精度不高。
	2.晶振
	  是一种特殊的晶体，通过打磨成不同的形状具有不同的导电特性。晶振特点就是精确性好。
	  缺点是不能集成到CPU内部，比需要外接晶振。
 
   ARM 里面的晶振的视图： P124
   由于板子上的晶振如果产生告诉频率的话，高频会导致信号干扰辐射等，所以，一般是产生一个低频信号，然后
   CPU内部有一个PLL(Phase Locked Loop锁相环)逻辑器件再把信号转换成高频信号。

   APLL：主要用于 CPU 核
   MPLL：CPU 系统级硬件，比如内存、串口、网卡等
   EPLL：外设使用

   电路图中设备名称：多路选择器，分频器，可配置分频器
   ARM6410 晶振产生的原始时钟是12MHz，通过PLL最大可达1.6GHz.
   可以通过设置SYNCMUX来选择两种模式:
	同步模式:CPU核 和 CPU系统级外设使用相同的时钟频率
	异步模式:CPU核 和 CPU系统级外设使用不相同的时钟频率

APLL_LOCK 用于设置APLL从低速到高速转换过程所用的时间. P141/P144

没有时钟时会停止所有执行，设置APLL_LOCK的代码是在频率已经基本转换以后才会执行的,以保证稳定性.
在进行转换时APLL是没有时钟信号的,所有的操作都会暂停.

================================================================================

  ARM异常
      未定义指令异常：当CPU执行时遇到一条未定义的指令，就会发生未定义指令异常，调用异常函数，该
		     异常函数工作在 未定义指令模式 。
      软中断异常：CPU执行swi软中断指令，触发软中断异常。相比于b跳转，软中断有模式切换，所以可以实现
                一些特权操作。工作在管理模式。

      预取指中止：在预取指过程中发生，工作在中止模式。
      数据中止：在取数据时发生，在工作在中止模式。
      (预取指中止 和 数据中止 都是因为内存错误造成的)      

      中断：由硬件引发
      快速中断：由硬件引发，其优先级要高于中断，而且只有一个硬件可以获得快速中断。

为了确定发生异常时能调用正确的异常处理函数，我们可以规定异常处理函数的名称 或者 固定它的地址。
但是，函数名本身也是地址，所以采用的方式是固定地址。也就是  中断向量表。
中断向量表中的异常处理位置是固定的，其中每一项存放的是一条跳转指令，跳向处理函数。
中断向量表的基地址是可变的：0x00000000 或 0xffff0000(3.9GB左右) 。  默认为0x0。
可以通过修改p15协处理器来修改向量表的基地址。
    跳转的方式:
	1.  b/bl/bxl 跳转 
	       但是有跳转范围是68M的限制
	2.  修改 pc 的值

中断的过程：
	1. 硬件 保存PC值到个异常模式的R14。
	2. 硬件 修改PC值，指向异常向量表的某个地址
	3. 硬件 原模式的CPSR被自动被保存到个异常模式的SPSR 
	4. 硬件 会把 CPSR 自动切换到各异常模式
	
	1. 软件准备异常向量表
	2. 编写异常处理函数：
		1.压栈 (r0-r3,r14)
		   stmfd sp!,{r0-r3,r14}
		2.出栈：
		   ldmfd sp!,{r0-r3,r14}
		   subs pc, r14, #4    @ 和模式相关	
           ------------------------------------------------------------
		另一种压栈出栈的方式(推荐方式)：
		   sub  r14, r14, #4
		   stmfd sp!, {r0-r3,r14}
		   ...
		   ldmfb sp!, {r0-r3,r14}^





中断嵌套的问题：当在处理一个中断的开始时，CPU默认是屏蔽其他中断发生的，所以不用担心会产生问题。
		当我们在异常处理函数中手动打开异常允许时，就要考虑到此时的跳转不会产生影响。

		swi_handler:
			stmfd sp!, {r0-r3,r14}
			sub  r0, r14, #8
			ldr  r1, [r0]
			bic  r1, r1, #0xff000000
                @ 也就是分析 swi 5 这条指令，其中的低24位就是软中断号
		@ 软中断可以实现 系统调用
         
      swi软中断的意义，就在于在用户模式下无法获得资源时，切换到特权模式来获得资源。
      但是，要保证这些特权模式的可靠性，必须有CPU等硬件上的支持。
			      
================================================================================

硬件中断信号的传送过程：
	以GPIO中断为例：
	触发GPIO中断－－GPIO控制器－－中断控制器－－CPU内部的中断控制寄存器－－CPU内核

我们的程序是以串口为例进行的。P1103 P410 P419。串口有四种中断信号。
	UINTSP 中断源寄存器，反应了最初的中断信号状态
	UINTP  中断未定寄存器，保存了传送到下一级的中断信号
	UINTM  中断屏蔽寄存器，允许通过的中断信号

非向量中断：当中断信号到达时直接跳转到指定的地址运行中断处理程序
向量中断  ：当中断到达时会先判断要跳转的地址，然后再进行跳转。
比如，有两个网卡，当地一个网卡产生中断是跳转到一个中断向量项；
另一个网卡会跳转到另一个中断向量项中。这就是向量中断。

--------------------------------------------------------------------------------
嵌套中断：
	不能无限嵌套
	不同中断具有不同的优先级

 对于在中断处理函数中，是否允许被再次中断 以及 怎样进行再次中断的处理：
    一般的处理方式是，在中断处理函数中首先进行必要的操作，然后主动切换到SVC管理模式。在这个切换过程中，我们要把
    原来中断的 {r0-r3,SPSR,r14} 都入栈保存，然后，栈指针 r13 保存到一个未分组的寄存器 r4(r0-r7)中；由于在SVC模式下
    仍然可以使用 r0-r7 寄存器，再把 r4 赋值给 r13(SVC模式) 这时出栈到{r0-r3,SPSR,r14};接着再入栈，这样就不会丢失原来的环境；
    1.中断函数保存现场到栈
    2.中断函数也可会做一些其他必要的操作
    3.把r13的值赋值给 r4
    4.通过修改CPSR切换到SVC模式
    5.把r4的值赋值给r13
    7.打开中断
    6.进行中断函数的处理例程，并等待其他中断的来临
    8.出栈返回
 

	
