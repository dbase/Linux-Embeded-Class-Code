		ARM指令集综述
	( 说明：<>中的内容表示可选，()中的内容表示必选 )
1.ARM基本汇编指令格式：   opcode<cond> rd,rn<,operand2>
	cond 条件码
	operand2 第二操作数，有三种方式：
	     @立即数，其有效位只能有8bits，但是会有4位的循环右移，右移的位数取值在0-30之间的偶数
	     @寄存器
	     @寄存器移位，这时的操作数是寄存器移位以后的结果(寄存器本身的值不变)，移位操作如下：
			lsl  逻辑左移
			lsr 逻辑右移
			asr 算术右移，正数补0，负数补1
			ror 循环右移，低端移出的位填入高端的空位
			rrx  扩展循环右移 ，右移一位，高端空出的位用原C标识位来填充，低端移出的位是新C的标志值

2.数据处理指令
	mov<cond><s> rd,operand2
	s 表示传送的数据是否将影响CPSR寄存器中的条件位，默认不影响
	mvn<cond><s> rd,operand2
	将operand2的值取饭，然后再放入rd中

3.算术和逻辑运算指令
	opcode<cond><s> rd, rn,operand2
	add 	rn+operand2 >rd
	adc       	rn+operand2+C > rd
	sub	rn-operand2 > rd
	sbc	rn-operand2+C-1 > rd
	rsb   	operand2-rn > rd		逆向减法指令
	rsc   	operand2-rn-C+1 > rd 	带借位的逆向减法指令
	and	rn&operand2 > rd		 与
	orr	rn|operand2 >rd		或
	eor	rn ^operand2 >rd 		异或
	bic	rn&~operand2 >rd		 位清除指令
注意：在有进位或借位的加减运算中，要考虑C标志位的值。进行加法时，C标志位为1说明发生了进位；
	进行减法运算时，C标志位为0说明发生了借位

4.比较指令
    比较指令的特点是运算结果不保存，只是影响CPSR中的标志位。所以，不用写出目的寄存器。
    比较指令实际上也是在进行运算，只是运算结果不进行保存而已。比较指令必须与后续指令的条件码搭配使用才有意义。
	opcode<cond> rn, operand2		
	cmp 	rn-opreand2 根据结果修改标志位		subs
	cmn	rn+operand2 根据结果修改标志位		adds
	tst 	rn&operand2  按位与，根据结果修改标志位	ands
	teq	rn^operand2 安位异或，根据结果修改标志位	eors
	
5.存储器访问指令
	ARM具有RISC处理器加载/存储体系结构，对存储器的访问只能使用ldr和str指令来实现。
	ldr指令用于读取存储器中的数据到寄存器，str用于将寄存器中的数据保存到存储器中。
	ldr<cond><s><h|b><t> rd, [rn<,offset>]<!>
	ldr<cond><s><h|b><t> rd, [rn]<,offset>
	str<cond><h|b><t> rd, [rn<,offset>]<!>
	str<cond><h|b><t> rd, [rn]<,offset>

	s : 只用于ldr并且必须于h/b一起使用，表示加载时高字节以有符号方式扩展，
	     即原数据是正数时扩展为0，原数据是负数时扩展为1，否则全部为0
	h : 表示对一个 16bits/字 进行操作。用于ldr时，取存储器中的两个字节并扩展为一个 32bits/双字 后放入寄存器；
	       用于str时，寄存器的高16bits无效。
	b : 表示对 8bits/字节 进行操作。用于ldr时，取存储器中的一个 8bits/字节 并扩展为一个 32bits/双字 后放入寄存器；
	      用于str时，寄存器高24bits无效。
	t : 表示将操作视为在用户模式下，在地址为前索引偏移方式时不可用
	
	ldr和str的寻址模式非常灵活。存储器地址由两部分组成：一部分为基址寄存器 rn，可以是任意一个通用寄存器；
	另一部分为地址偏移量，而地址偏移量又有3种格式：
		@立即数，可以是正数或负数
		@寄存器，寄存器中的值作为偏移量，可以加在rn基址上，也可以从基址中减去(在前面加负号)
		@寄存器移位，此时移位数是一个常数，寄存器移位后的值可以加在基址上，也可以从基址中减去(前面加负号)
	
	从寻址时的地址计算方法分，ldr和str有4种形式：
		@零偏移，地址偏移量为0
		@前索引偏移，先进行基址加偏移量得到地址，取值，然后放到rd中，如果后面有'!'，则同时将相加后得到的地址回写到rn；
			            这时偏移量写在方括号中
		@后索引偏移，先以基址为地址取得数据，送到rd中，然后再将偏移量与基址相加回写到rn；这时偏移量写在方括号后。
		@PC相对偏移，以PC作为基址寄存器

	当使用前索引和后索引偏移时，基址寄存器不能是PC。对于PC相对偏移寻址的情况，指令的写法不遵循上述形式，如：
		ldr  r0,label
		其中，label是一个程序中的标号，编译器将自动计算标号与当前PC值的相对偏移量并生成一条前索引的存储指令。
	还有就是，访问存储器时，要注意地址的对齐，即读写32位数据时，地址必须是4的整数倍；读写16位数据时，地址必须是2的整数倍。
           ==========================================================================
	ldm 和 stm 指令：
	ldm指令用于读取存储器中连续的多个数据到多个寄存器，stm指令用于将多个寄存器中的数据保存到存储器的连续空间中。
	ldm<cond>(i|d)(a|b) rn<!>,{reglist}<^>
	stm<cond>(i|d)(a|b) rn<!>,{reglist}<^>
	
	i : 每次传送基址加4
	d : 每次传送基址减4
	a : 传送一个寄存器后基址变化(+4/-4)
	b : 传送一个寄存器之前基址变化(+4/-4)
	rn : 基址寄存器，用于存放内存中的基地址。如果rn是sp时，这些指令的作用就是入栈和出栈操作。
	reglist : 要传送的寄存器列表		
	! : 表示变化后的基址会回写到 rn基址寄存器中，且rn不可以是 R15
	^ :  作用比较特殊，它不能在用户模式和系统模式下使用。如果在ldm的寄存器列表中有PC并且使用了'^'符号，则除了传送所指定的
	         寄存器外，还会将SPSR复制到CPSR中，这可以用来从异常模式中返回。
	        如果使用了'^'符号并且寄存器列表中不包含PC，操作的是用户模式下的寄存器而不是当前模式下的寄存器。
	{reglist} : 列表中的多个寄存器用逗号隔开，如果是多个连续的寄存器，可以使用连字符，如 :
		stmia r0!, {r3-r5,lr} 
		另外，列表中的寄存器不能重复，并且最好是按照从小到大的顺序排列。
	
	鉴于栈操作的重要性，对指令的格式重新定义如下：
	ldm<cond>(f|e)(d|a)  sp<!>,  {reglist}<^>
	stm<cond>(f|e)(d|a)   sp<!>, {reglist}<^>

	f : 满栈，先更改SP的值，然后将数据放入到SP指向的内存中，即栈指针总是指向刚入栈的元素
		sub  sp,#0x4
		ldr  sp,[r0]
	e : 空栈，先存放数据，然后再修改SP的值，即栈指针总是指向刚入栈的元素的下一位置
		ldr  sp,[r0]
		sub  sp,#0x4

	d : 递减堆栈，即入栈操作使栈指针递减
	a : 递增堆栈，即入栈操作使栈指针递增
	注意：这些指令只对32位长度的数据进行操作，地址的低两位将被忽略。
	   ARM 默认是满减栈。
           ==========================================================================
	swp指令：
	swp指令用于交换寄存器和存储器中的值。
	swp<cond><b>  rd, rm, [rn]

	b : 表示对字节进行操作
	rd : 目标寄存器，从存储器中读到的数据放入到此寄存器中
	rm : 第一操作数寄存器，此寄存器中的值写入存储器
	rn : 基址寄存器，存储器的地址
	注意：当rd和rm相同时就实现了交换寄存器和存储器的值。另外就是ARM保证这一操作的原子性，所以swp指令可以用来实现
	             类似加锁的功能。

6.分支指令
	在ARM汇编中可以使用两种方式来实现指令的跳转：一种是修改PC的值；另一种就是使用分支指令b,bl,bx等。
	b指令：
	b指令使程序跳转到指定的地址。
	b<cond> label
	b指令的实质就是给PC寄存器的值加/减一个偏移量，因此是一种相对跳转。ARM机器指令中为跳转指令留出了24bits作为偏移量，	
	由于ARM指令是32bits的，所以每条指令的地址最后两位均为0，所以其实可以寻址24x4=64MB的范围，也就是当前指令前后32MB的范围内。
           ==========================================================================
	bl指令：
	bl指令首先将下一条指令的地址复制到lr寄存器中，然后使程序跳转到指定的地址，因此常用来调用子程序。
	bl<cond>  label
	bl和b指令类似也是相对跳转，并且有32MB的限制。
           ==========================================================================
	bx指令：
	bx是带状态切换的跳转指令。
	bx<cond> rm

	rm : bx把rm的值复制到PC寄存器实现跳转，并且如果rm的最低位是1，则同时将CPSR中的T标志位置1，也就是处理器将进入Thumb指令状态；
	        如果rm的最低位为0，则同时将CPSR中的T标志位清零，也就是进入执行ARM指令状态。

7.软中断指令
	swi是软中断指令，用于产生软中断异常。
	swi<cond> no
	
	no : 是一个24bits的立即数
	swi指令执行以后，下一条指令的地址被保存到LR寄存器，CPSR的值保存到管理模式SVC的SPSR中，处理器切换到管理模式，
	执行流程转移到软件中断异常入口。
	swi在操作系统中用来实现系统调用。no这个立即数是被处理器忽略的，但软件可以利用它来传递系统调用功能号。
	Linux上的传统ABI(Application Binary Interface)就采用这种方式，另外，最新的EABI(Embeded ABI)使用R7寄存器来传递功能号，
	而swi指令中的立即数被设为0。

8.程序状态寄存器传送指令
	mrs指令：
	mrs指令用于读程序状态寄存器，它是唯一可以读CPSR或SPSR的指令。
	mrs<cond> rd,psr
	
	rd : 目标寄存器，用于存放程序状态寄存器，不可以是PC
	psr : CPSR或SPSR
           ==========================================================================
	msr指令：
	msr指令用于写程序状态寄存器，它也是唯一可以直接写CPSR/SPSR的指令。
	msr<cond> psr_fields, (im8|Rm)
	
	psr : cpsr或spsr
	fields : 指定写入的区域。字母c表示写入第0-7位(控制位)，x表示写入第8-15位, s表示写入第16-23位，f表示写入第24-31位(标志位)。
		可以同时有多个字母。
	im8 : 8位立即数
	Rm : 存放信息的寄存器

	注意：只有在特权模式，即非用户模式下才能修改程序状态寄存器。
	             msr指令不能直接修改CPSR的T控制位来切换ARM/Thumb指令状态，必须使用bx。
	             通过修改CPSR或SPSR的值可以进行处理器模式的切换以及禁用/使能程序状态寄存器等操作。

9.乘法指令
	ARM中的乘法指令按照结果的位数可分为32位乘法指令和64位乘法指令。
	32位乘法指令：	
	          mul指令：
	          mul指令，用于将两个寄存器相乘。
	          mul<cond><s> rd, rm, rs

	          (rm*rs)(low 32bits) > rd
	          它的作用是将rm和rs寄存器的值相乘并将结果的低32bits保存到rd中。

	          mla<cond><s> rd, rm, rs, rn

	          ((rm*rs)+rn)(low 32bits) > rd
	          注意：目标寄存器不能是R15
           ==========================================================================
	64位乘法指令：
	umull<cond><s>  rdlo, rdhi, rm,rs
	smull<cond><s>   rdlo,rdhi, rm,rs
	
	s : 表示结果是否影响条件标志位
	rdlo : 用于存放结果的低32bits的目标寄存器
	rdhi : 用于存放结果的高32bits的目标寄存器
	rm,rs : 用于存放相乘的两个数

	注意：umull指令将所有的操作数和结果作为无符号数处理；smull将所有的操作数和结果当成有符号数处理。
	
	64位乘法与加法组合的指令：
	umlal<cond><s> rdlo,rdhi, rm,rs
	smlal<cond><s> rdio,rdhi, rm,rs
		
	注意：这两条指令会将rm和rs的值相乘的结果加上有rdhi和rdlo组成64bits整数作为最终的结果并保存到rdhi和drdlo中。

10.协处理器指令
	ARM架构支持协处理器，相应的也有对协处理器进行控制的命令。这些命令中一般都需要指明所操作的协处理器。
	ARM支持16个协处理器，编号从0-15，指令中用字母p加上编号来表示一个协处理器。
	注意：如果协处理器不能成功执行指定的操作，就会产生未定义指令异常。
	
	cdp指令：
	cdp指令用于通知协处理器执行指定的操作。
	cdp<cond> pn, opcode1, crd,drn,crm<, opcode2>

	pn : 协处理器
	opcode1 : 协处理器的第一操作码，它的含义由协处理器来解释
	crd : 协处理器的目标寄存器
	crn : 协处理器的第一操作数寄存器
	crm : 协处理器的第二操作数寄存器
	opcode2 : 协处理器的第二操作码，它的含义由协处理器来解释
           ==========================================================================
	ldc和stc指令：
	ldc用于从存储器读取数据到协处理器的寄存器中；stc则把协处理器的寄存器的数据保存到存储器中。
	
	ldc<cond><l> pn, crd ,addr
	stc<cond><l> pn, crd, addr
	
	l : 表示传送的是长整数
	pn : 协处理器
	cdr : 协处理器的目标寄存器
	addr : 地址，地址的格式和ldr、str的指令相同
	注意：数据的传送由协处理器来控制。
           ==========================================================================
	mcr和mrc指令：
	mcr用于从ARM处理器的寄存器向协处理器的寄存器传送数据；mrc用于从协处理器寄存器向ARM寄存器传送数据
	
	mcr<cond> pn, opcode1, rd, crn, crm<, opcode2>
	mrc<cond> pn, opcode1, rd, crn, crm<, opcode2>
	
	它的格式与cdp指令类似，只不过目标寄存器换成了ARM处理器自己的寄存器。

11.伪指令
	为了方便编程，ARM汇编中定义了一些伪指令，这些伪指令并不与某条机器指令对应而是由汇编器将其替换成一条或多条等效的ARM指令。
	
	adr伪指令：
	adr伪指令用来向寄存器传送一个地址值。
	
	adr<cond> rd, addr
	
	rd : 用于存放地址的目标寄存器
	addr : 一个地址值
	注意：addr一般是一个标号。编译器产生的指令会把当前PC值加上或减去一个固定的偏移量作为地址。
           ==========================================================================
	ldr伪指令：
	由于使用mov或mvn指令向寄存器传送的立即数是受到一定限制的，因此ldr伪指令可以向寄存器传送任意的立即数。
	
	ldr<cond> rd, =im32
	
	im32 : 一个32bits的常数
	
	它与存储器访问ldr指令的区别在于常数前面是一个=等号。实际的实现可能是mov或mvn，也可能是将常数放到存储器中，再用ldr进行加载。
	ldr伪指令也可以用来传送地址，与adr的区别在于：ldr伪指令不是以相对于当前PC值的方式来生成指令，因而不受偏移量的限制。
           ==========================================================================
	nop伪指令：
	nop伪指令不做任何操作，但是占用指令的执行时间。
	
	nop
	
	nop可以实现软件上的延时。

*****************************************************************************************************************************************
	ARM汇编的两种方式
	ARMSAM：ARM公司推出的，用于windows下，完全符合ARM汇编标准。
	GUN ARM SAM：GUN交叉编译工具链中的汇编器。用于LINUX下。
	
	GUN ARM 汇编语法：
	GUN ARM汇编所支持的一些指示性的关键字，通常也被成为伪指令，但是注意要和ARM自身的伪指令相区别。
	如果想注释整行，要在行首添加一个'#'; 另外，指令中的立即数应添加一个 '#'或'$'字符。
	一行中的多条语句可以使用分号隔开。

	一行语句的基本格式：
		标签:     指令      @注释
	
	如：
		ldr	r1, =str
		mov	r2, r1
	1:	ldr	r0, [r2], #1
		cmp	r0,#0
		beq	2f
		bne	1b
	2:	sub	r3, r2, r1
	
	上面的实例中'1:'和'2:'成为局部标签。局部标签只能是0-99的数字，使用时要在数字后加上 b或f，b表示向前搜索最近的一个标签作为目标；
	f 表示向后搜索最近的一个标签作为目标。局部标签在宏定义中十分有用，因为宏会在源代码中多次使用，也就意味着其内的标签会出现多次。
	
	一个简单的示例，定义一个add函数，用于返回两个参数的和：
		.text   		@代码段的开始
		.global  add  	@声明为全局标签，以在其他文件中使用
	add:			@标签
		add 	r0, r0, r1
		mov	pc, lr         @函数调用返回
           ==========================================================================	
	常用的GUN ARM汇编伪指令
	
	.equ 伪指令用于定义一个常数。
	
	.equ	symbol, value
	
	value : 是一个值为常数的表达式。
	注意：GUN ARM汇编也支持C语言中的#define与处理指令。
	-------------------------------------------------------------------------------------------
	.globl伪指令用来声明一个全局的标签。
		
	.globl	label
	
	label : label是程序中的一个标签。label将会被导出到目标文件，从而可以与其他目标文件连接在一起。
	-------------------------------------------------------------------------------------------
	.req伪指令用于定义寄存器的别名。
	
	alias	.req  reg
	
	alias : 寄存器的别名。
	-------------------------------------------------------------------------------------------
	数据定义伪指令
	.ltorg 用于声明文字池。
	
	.ltorg
	
	文字池的作用是存放ldr伪指令所传送的数据。文字池应该声明在程序正常执行达不到的地方，如无条件跳转指令之后或子程序返回之后，
	以免其中的数据被当作指令来执行。如果不声明文字池，则汇编器会在程序的末尾自动加上文字池。
	-------------------------------------------------------------------------------------------
	.byte用于定义字节型数据。
	.byte	byte1, byte2, ...
	
	.hword定义16bits型数据。
	.word定义32bits型数据。
	
	.hword	hword1,hword2, ...
	.word	word1, word2, ...

	.ascii定义字符串。
	.ascii   	"string"
	注意：字符串末尾并不会自动添加'\0'结束符。
	
	.asciz 定义一个字符串，并且会自动在末尾添加'\0'.
	.asciz	"string"
	-------------------------------------------------------------------------------------------
	.align伪指令用于填充一些字节以使随后的地址对齐指定的边界。
	
	.align	power_of_2<, fill_value>
	
	power_of_2 : 随后的地址将是2的power_of_2次幂的整数倍。
	fill_vlue : 要填充的数据，可选

	.space 伪指令用于填充空白数据。
	.space	count<, fill_byte>
	
	count : 要填充的字节个数
	fill_byte : 要填充的数据，可选，如果省略则默认填充0
==========================================================================	
	GUN ARM控制伪指令
	
	@代码分支
		.if expr
		code1
		.else
		code2
		.endif
	注意：GUN ARM汇编也能识别C中的#if等预编译指令。与#if不同的是.if不是在预处理阶段处理 ，而是在汇编过程中处理。
	
	@循环
		.rept times
		code
		.endr
	另一种方式的循环形式如下：
		.irp	param, val1, val2, ...			
		code
		.endr
	在code中可以引用参数param，形式是一个参数名前面添加一个反斜杠\.
		.rep	n, 1, 3, 4
		mov 	r\n, #0
		.endr
	
	@宏定义
		.macro	name arg1, arg2, ...
		code
		.endm
	举例：
		.macro	shift_left	a, b
		.if     \b < 0                                 @如果b是负数
		mov	\a, \a, asr #-\b
		.exitm			@跳出宏
		.endif
		mov	\a, \a, lsl #\b
		.endm			@结束宏
	我们就可以如下使用该宏：
		shift_left  r0,-2
	
	@段定义
		.section	name<, "flag">
		
		name : 段的名字
		flag : 表示访问权限,可选的，如果要生成elf格式的可执行程序，则有如下值：
			a : 表示允许访问
			w : 允许写
			x : 允许执行
	汇编器能够识别一些预定义的段名:
			.text     .data    .bss
	注意：如果有自定义的段名，则必须提供链接脚本才能成功链接。
	
	@文件包含以其他
		.include "filename"
	同样也可以使用#include来包含。
		
		.arm/.code 32      指示随后的代码应编译成ARM指令
		.thumb/.code 16  指示随后的代码应编译成Thumb指令

		.err    可以使编译过程出错并终止
		.end   表示汇编代码结束，通常省略。
		
